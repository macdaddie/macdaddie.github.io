= Useful Unix

== Useful `Find`

=== Converting xlsx files to csv

[source,shell]
----
find . -type f -iname "<paturn>*.xlsx" -exec sh -c 'in2csv "$1" --format xlsx > "${1%.xlsx}.csv"' _ {} \;
----

=== Deleting recursive files & directory structure

[source, bash]
find . -name "FILE-TO-FIND"-exec rm -rf {} \;

=== Deleting recursive files but leaving directory structure

[source, bash]
find . -type f -name "FILE-TO-FIND" -exec rm -f {} \;

=== Finding empty directories and deleting them

[source, bash]
find . -type d -empty -exec rmdir {} \;

=== Deleting files of a certain size

[source, bash]
find . -size <size>c -exec rm {} \; --where c=kb M=MB, etc

NOTE: If you want less than a specific size for <size> put (eg) `-20M` or more `+20M`

=== Removes all files older than and including <file>

[source, bash]
find . ! -newer <file> -exec rm -rf {} \;

=== To display filename and line count minus 1 for csv files (well, any text file)

[source, bash]
----
for i in`ls -1`; do echo -n "$i,"; j=`cat $i|wc -l`;j=`expr $j - 1`;echo $j; done
# or
wc -l * | awk '{ if ( $2 != "total" ) printf"%s,%s\n",$2,$1-1}'
----

=== To remove whitespace and replace with underscores from file names recursively

[source, bash]
for i in`find . -name '\*\*' | tr ' ' '~'`; do mv "$(echo $i| tr '~' ' '|sed 's/ /\\ /g')" "$(echo $i | tr '~' '_')"; done

=== How to flatten a directory structure

[source, bash]
find . -type f -name "*mp3" -print0 | xargs -0 -J% mv % <destination_directory>

=== Display full paths to files for recursive directories

[source, bash]
find `pwd`-name "*.*"

=== Full path listings

[source, bash]
find .

or

[source, bash]
for i in `ls -1`;do echo `pwd`\/$i; done

or in awk (courtesy of Dave Leather)

[source, bash]
ls|awk '{print "'`pwd`'/" $1}

If you want to exclude certain files based on file name use this (example here is "small")

[source, bash]
ls *.jpg|awk '{if ( $0 !~ /small/) print "'`pwd`'/" $1}

(To do this on inclusion rather than exclusion drop the !)

=== Find all the instances of a pattern in excel files and pipe them to a file

[source, bash]
find . -name '*.xls'

=== Find all the instances of a pattern in excel files and pipe them to a file with associated file name

[source, bash]
find . -name '*.xls' -exec grep -b -n -i vtx {} /dev/null ';' | strings | egrep 'vx|VX|.xls:' | awk '{if ( $0 ~ /.xls:/ ) { file=sprintf("%s",substr($0,1,index($0,":"))) ;getline} ; print file,$0 }'

=== `Find` and Symlinks

==== Find broken symlinks

[source, bash]
find . -type l -print -exec file {} +|grep broken

==== Show target and source of symlinks in a dir

[source, bash]
find . -type l -exec readlink {} \; -exec echo {} \;|awk '{printf"%s - ", $0 ; getline ; print $0 }'

==== Fix broken simlinks were the dir has moved down a sub dir

> xxx ## never got it from Dave leather

=== Counting all the words in a given type of file in a recursive directory

[source,shell]
----
find . -type f -name "*.md" -exec cat {} + | grep -oE '\w+' | wc -w
----

=== Remove spaces from a file name recursively and replace with underscores

[source,shell]
----
find . -name '**' | while read file;
do
target=`echo "$file" | sed 's/ /_/g'`;
echo "Renaming '$file' to '$target'";
mv "$file" "$target";
done;
----

=== Flattening a dir

NOTE: `-print0` is mac specific to handle spaces in file names

---

[source, bash]
find . -type f -name "*vsd" -print0|xargs -0 -J% cp % /Volumes/Charles05/charles/cw/customers/vertex/One/design/visio_vdx

=== `find` and `gzip`

==== Find everything called archlog\*.dbf and then compress it

`find . -type f -name "archlog*.dbf" -exec gzip {} \;`

==== Find everything older than two days and compress it

`find . -type f -name "archlog*.dbf" -mtime +2  -exec gzip {} \;`

== `tar` & `gzip`

=== Compress all logs with this name

`gzip archlog*.dbf`

[source,shell]
----
cd <dir>
for f in `ls arch*.dbf`
do
if [ -z `fuser $f` ] ; then
   gzip $f
else
   echo "$f is in use"
fi
----

or this:

[source,shell]
----
cd <archdir>
find . -type f ! -newer `ls -1tr | tail -1` -xargs gzip {} \;
----

=== Gzip a directory to a single file

[source, bash]
tar cvf - <directory to be zipped>|gzip > <filename of single file to compress to>.gz

=== Back-to-back-tar

How to push a whole file system from one machine to another through ssh

[source, bash]
tar cf - * | ssh -c blowfish file_share@tiger "cd /Users/file_share/jad; tar xf -"

== Useful `dd`

The basic syntax for dd is:

[source, bash]
dd if=INPUT-FILE-NAME of=OUTPUT-FILE-NAME

=== Copying A Disk To A Disk Image Using dd

[source, bash]
dd bs=512 if=/dev/rXX# of=/some_dir/foo.dmg conv=noerror,sync

NOTE: `conv=noerror,sync` skips bad blocks and fills the target with nulls, thereby making it an excellent way to recover a broken disk, so long as it mounts.

=== Making an ISO image using dd

To make an ISO from your CD/DVD, place the media in your drive but do not mount it. If it automounts, unmount it.

[source, bash]
----
dd if=/dev/dvd of=dvd.iso # for dvd
dd if=/dev/cdrom of=cd.iso bs=2048 # for cdrom
dd if=/dev/scd0 of=cd.iso # if cdrom is scsi
----

=== Burning Disk Image To Disk / Usb Using dd

[source, bash]
sudo dd if=/Volumes/CSW_FW_02/software/OSX/Install\ OS\ X\ Mountain\ Lion.app/Contents/SharedSupport/InstallESD.dmg of=/dev/disk8 bs=1m

NOTE: Eug-Lug states that a reliable bs for modern HDD's is bs=64k

== `grep`

=== Grepping for multiple words use egrep

[source, bash]
----
egrep "(<word1>|<word2>)" filename

e.g. `egrep "(CREATE|DROP)" IS001A.sql`
----

== `fsck`

=== Full `fsck`

[source, bash]
fsck -F vxfs -o full -y <File system>

e.g. `fsck -F vxfs -o full -y /dev/vx/dsk/bcv1OtherDbs-livedg/OtherDbs-orabin-9i`

== `sudo`

=== Keeping the sudo token active

[source,shell]
----
while true
do
sudo ssh crockofshi7
sleep 180
done
----

or

`while true; do sudo ssh thingy; sleep 240; done`

== Finding how many processors

[source, bash]
psrinfo

== Finding out where the large files are

[source, bash]
du -sk *

== pkill

=== Killing processes by name

[source, bash]
pkill -9 <string>

== User Management

=== Adding users

[source, bash]
useradd -g 10 -d /export/home/charlesisapoof -m -s /bin/ksh -c "Charles Webster" websterc

== Sun inventory

[source, bash]
/usr/platform/SUNW,Sun-Fire-V245/sbin/prtdiag

== Solaris

=== Displaying kernel parameters not listed is /etc/system

[source, bash]
sysdef

== Script To Read A Log File Showing The Current And A Backup Of A File And Report The Differences

[source,shell]
----
ls -t /u01/app/oracle/product/istore/cwciteappl/admin/CWCITE_ordsvywat-sun-09/log/*/adconfig.log | head -1 | \
awk '{ printf" grep backup %s\n",$0 }' |sh  |\
awk '{print "cmp " $3 " " $5 }' | sh
----

== LINUX with HP RAID Controller

Checking status of HP Raid Controller

[source, bash]
/usr/sbin/hpacucli controller slot=0 pd all show

== Mounting a SMB / NFS drive

[source, bash]
----
mount -t smbfs <smb_drive_to_mount_with_auth> <local_mont_location>

mount -t smbfs //cwebster@bdc.localnet/CSW01 /<path_to_mount_point/<mount_point>
----

=== On osx

[source, bash]
mount_smbfs //cwebster@bdc.localnet/CSW01 /<path_to_mount_point/<mount_point>

== link:./useful_ssl/Useful_OpenSSL.md[useful Openssl]

=== Encrypt a file using OpenSSL

This is a pretty simple way to encrypt a single file so that it is nearly impossible for others to read, and it will require a password to access again. Youâ€™ll need to use the OpenSSL technology via the command line for this to work.

=== Encrypt the file

[source, bash]
openssl enc -e -a -salt -bf -in <plain_filename.txt> -out <encrypt_filename.txt>

enter bf-cbc encryption password:
Verifying password - enter bf-cbc encryption password:

=== Decrypt file

[source, bash]
openssl enc -d -a -bf -in <encrypt_filename.txt> -out <plain_filename.txt>

enter bf-cbc decryption password:

== Port Scanning

=== Scan a range of servers for a specific port

[source, bash]
for i in $(seq 160 170); do nc -v -n -z -w 1 10.196.52.$i 389; done

=== Scan a server for a specific port

[source, bash]
nc -z gbcwswiep005.ad.plc.cwintra.com 100-700

=== Finding other machines on your network (same broadcast domain)

Find the broadcast address
[source, bash]
----
ifconfig -a | grep broadcast
# `ping` it  
ping -i 5 -c 2 <broadcast_address>
----

Alternatively `arp -a` will give you all the machines your computer has previously interacted with.

=== Checking internet connectivity

[source, bash]
----
curl -s --max-time 2 -I <http://google.com>

# or

curl --silent --head <http://www.google.com/>
----

=== Download speed

[source, bash]
----
curl -o /dev/null <http://speedtest.wdc01.softlayer.com/downloads/test500.zip>
or
curl -s <https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py> | python -
----

=== Checking a specific port is open

[source,sql]
----
while ! nc -zv portico-mna-westus3.azurewebsites.net 1433; do echo "Connection failed, retrying in 5 seconds..."; sleep 5; done && echo "Connection successful"
----

== `mkdir`

=== Make nested directory structure

[source, bash]
mkdir -p <customer_dir>/{quotes,HLD,delivery,HIE???,discovery,discoverycommercal/{pricing,EDRA/{EDRA1,EDRA2,EDRA3,EDRA4},SF1,PO}}

== Remove all the newlines from a file - useful for cleaning up sql imports

[source, bash]
tr -d '\n' < input.txt > output.txt

== Finding and counting the unique list of file types recursively in a directory

[source,shell]
----
find . -type f | rev | cut -d. -f1 | rev  | tr '[:upper:]' '[:lower:]' | sort | uniq --count | sort -rn
----

== Useful ls

=== Delete all but the most recent file of type `bin`

[source,bash]
----
# This actually uses `eze` but the same can be achieved with `ls -t`
ls -snew -1 -r *.bin| tail -n +2|xargs rm --
----

== Useful ps

* `ps -ef|grep -i <process-you-are-trying-to-find>` will find the PID of the process you have entered some identifying text for.
* Use `ps -p <PID> -o pid,ppid,comm,args` to get the actual name of the program and it's location

== Useful lsof

* Use `lsof -i :<port_number>` to find what processes are using a given port
